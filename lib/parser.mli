(** Module Parser contains the main parser functor. *)

(** Represents a position within a source file. *)
type position =
  { line : int
  ; column : int
  }

(** [initial_position] is the first position in a source file. *)
val initial_position : position

(** [inc_line position] returns a new position on the following line with
    respect to [position]. *)
val inc_line : position -> position

(** [inc_column position] returns a new position on the following column with
    respect to [position]. *)
val inc_column : position -> position

(** [pp_position oc position] prints [position] in a nice format to [oc].
    This can be used with the [%a] directive in Printf. *)
val pp_position : out_channel -> position -> unit

(** Represents the parser state *)
type 's state =
  { input : 's
  ; index : int
  ; position : position
  }

(** [state_from_stream stream] initializes the state from [stream]. *)
val state_from_stream : 's -> 's state

module type StreamType = sig
  (** Contains a token stream type which can be parsed. *)

  (** The main stream type. *)
  type t

  (** The token type generated by {!t} *)
  type token

  (** [next_token state] generates the next token, together with an updated
      state, if there still is one available. Otherwise returns [None] *)
  val next_token : t state -> (token * t state) option

  (** [pp_token () token] prints [token] in a nice format. This can be used
      in [Printf.sprintf]. *)
  val pp_token : unit -> token -> string
end

module type S = sig
  (** Contains a parser type which can parse some kind of token stream. *)

  (** The main parser type. *)
  type 'a t

  (** The stream type. *)
  type stream

  (** The token type. *)
  type token

  (** The type for labeling parsers. *)
  type parser_label = string

  (** The type for when parsing fails. *)
  type parser_error = string

  (** Wrapper around [Result] to represents parse results *)
  type 'a parse_result = ('a, parser_label * parser_error * position) Result.t

  (** [pp_error oc error] prints [error] in a user readable format to [oc]. *)
  val pp_error : out_channel -> parser_label * parser_error * position -> unit

  (** [run parser stream] runs [parser] on [stream] and returns the result.

      See also {!run_eof}. *)
  val run : 'a t -> stream -> ('a * stream state) parse_result

  (** [run parser stream] runs [parser] on [stream], expecting the stream to
      be at its end and returns the result.

      See also {!run}. *)
  val run_eof : 'a t -> stream -> 'a parse_result

  (** [fail message] returns a parser which always fails with [message]. *)
  val fail : string -> 'a t

  (** [const value] returns a parser which always succeeds returning [value]. *)
  val const : 'a -> 'a t

  (** [satisfy predicate label] returns a parser which succeeds if for the next
      token in the stream [predicate] holds. If not, the parser fails and is
      given [label]. *)
  val satisfy : (token -> bool) -> parser_label -> token t

  (** [eof] returns a parser which only succeeds if the stream can no longer
    produce tokens *)

  (** [eof] returns a parser which only succeeds if the stream can no longer
      produce tokens. *)
  val eof : unit t

  (** [with_label label parser] returns a new parser which is the same as
      [parser] except for the new [label]. *)
  val with_label : parser_label -> 'a t -> 'a t

  (** [bind parser f] returns a parser based on the result of applying [f] to
      the result of [parser]. If [parser fails], or [f] produces a parser which
      fails on the following input, [bind parser f] will fail.

      See also {!Operators.( >>= )}, and {!Monad_syntax}. *)
  val bind : 'a t -> ('a -> 'b t) -> 'b t

  (** [map f parser] returns a parser which takes the result of [parser] and
      calls [f] on it, which becomes the new result. If [parser] fails,
      [map f parser] will fail.

      See also {!Applicative_syntax}. *)
  val map : ('a -> 'b) -> 'a t -> 'b t

  (** [and_then parser1 parser2] returns a parser which runs [parser1] on the
      stream, then [parser2] on the updated stream, and returns a tuple pair
      of both there results.

      See also {!Operators.( *>>* )}, {!Applicative_syntax}, and
      {!Monad_syntax}. *)
  val and_then : 'a t -> 'b t -> ('a * 'b) t

  (** [keep_left parser ignored] returns a parser which runs both parsers, but
      ignores the result of the right one.

      See also {!Operators.( *>> )}. *)
  val keep_left : 'a t -> 'b t -> 'a t

  (** [keep_right ignored parsed] returns a parser which runs both parsers, but
      ignores the result of the left one.

      See also {!Operators.( >>* )}. *)
  val keep_right : 'a t -> 'b t -> 'b t

  (** [between left right parser] returns a parser which runs [left], then
      [right], and then [parser], but only keeps [parser]'s result. This can
      be used to parse parentheses around an expression.*)
  val between : 'a t -> 'b t -> 'c t -> 'c t

  (** [sequence parsers] returns a parser which runs all [parsers] in order on
      the stream, updating the stream after each parser. If one parser fails,
      [sequence parsers] fails with the failing parser's error message. *)
  val sequence : 'a t list -> 'a list t

  (** [or_else parser1 parser2] returns a parser which tries to run [parser1],
      and if it fails runs [parser2]. *)
  val or_else : 'a t -> 'a t -> 'a t

  (** [choice parsers] returns a parser which tries to run all [parsers],
      backtracking each time, and returns the first result for which the parser
      succeeds. *)
  val choice : 'a t list -> 'a t

  (** [many parser] returns a parser which keeps running [parser] as long as it
      succeeds. It returns all the successfully parsed values in a list. It
      is allowed to never parse successfully.

      See also {!some}, {!opt}, and {!sep_by}. *)
  val many : 'a t -> 'a list t

  (** [many parser] returns a parser which keeps running [parser] as long as it
      succeeds. It returns all the successfully parsed values in a list. It
      must parse successfully at least once.

      See also {!many}, and {!opt}, and {!sep_by_1}. *)
  val some : 'a t -> 'a list t

  (** [opt parser] returns a parser which tries to run [parser], returning its
      result wrapped in an option if it succeeds. If not, [None] is returned.

      See also {!many}, and {!some}. *)
  val opt : 'a t -> 'a option t

  (** [sep_by_1 separator parser] returns a parser which runs [parser]
      repeatedly, separated by [separator], returning the values in a list. It
      must parse successfully at least once.

      See also {!some}. *)
  val sep_by_1 : 'b t -> 'a t -> 'a list t

  (** [sep_by separator parser] returns a parser which runs [parser] repeatedly,
      separated by [separator], returning the values in a list. It is allowed to
      never parse successfully.

      See also {!many}. *)
  val sep_by : 'b t -> 'a t -> 'a list t

  (** Contains some operators for a more DSL-like experience. *)
  module Operators : sig
    (** [parser <?> label] is a shorthand for [with_label label parser]. *)
    val ( <?> ) : 'a t -> parser_label -> 'a t

    (** [parser >>= f] is a shorthand for [bind parser f]. *)
    val ( >>= ) : 'a t -> ('a -> 'b t) -> 'b t

    (** [parser1 *>>* parser2] is a shorthand for [and_then parser1 parser2]. *)
    val ( *>>* ) : 'a t -> 'b t -> ('a * 'b) t

    (** [parser1 *>> parser2] is a shorthand for [keep_left parser1 parser2]. *)
    val ( *>> ) : 'a t -> 'b t -> 'a t

    (** [parser1 >>* parser2] is a shorthand for [keep_right parser1 parser2]. *)
    val ( >>* ) : 'a t -> 'b t -> 'b t

    (** [parser1 <|> parser2] is a shorthand for [or_else parser1 parser2]. *)
    val ( <|> ) : 'a t -> 'a t -> 'a t
  end

  (** Contains applicative [let] operators. *)
  module Applicative_syntax : sig
    (** [let+ value = parser in f value] is equivalent to [map f parser]. *)
    val ( let+ ) : 'a t -> ('a -> 'b) -> 'b t

    (** [let+ value1 = parser1 and+ value2 = parser2 in f value1 value2] is
        equivalent to
        [map (fun (value1, value2) -> f value1 value2) (parser1 *>>* parser2)]. *)
    val ( and+ ) : 'a t -> 'b t -> ('a * 'b) t
  end

  (** Contains monadic [let] operators. *)
  module Monad_syntax : sig
    include module type of struct
      include Applicative_syntax
    end

    (** [let* value = parser in f value] is equivalent to [bind parser f]. *)
    val ( let* ) : 'a t -> ('a -> 'b t) -> 'b t

    (** [let* value1 = parser1 and* value2 = parser2 in f value1 value2] is
        equivalent to
        [bind (parser1 *>>* parser2) (fun (value1, value2) -> f value1 value2)]. *)
    val ( and* ) : 'a t -> 'b t -> ('a * 'b) t
  end
end

(** [Make (Stream)] returns a parser module based on [Stream]. *)
module Make (Stream : StreamType) :
  S with type stream := Stream.t and type token := Stream.token
